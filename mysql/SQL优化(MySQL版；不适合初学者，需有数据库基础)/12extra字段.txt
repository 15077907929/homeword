(8)extra
	(ii).using temporary:性能损耗比较大，用到了临时表。一般出现在group by语句中。需要额外使用一张表
		select a1 from test02 where a1 in('1','2','3') group by a2;
			+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+
			| id | select_type | table  | type  | possible_keys | key          | key_len | ref  | rows | Extra                                                     |
			+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+
			|  1 | SIMPLE      | test02 | index | idx_a1_a2_a3  | idx_a1_a2_a3 | 30      | NULL |    1 | Using where; Using index; Using temporary; Using filesort |
			+----+-------------+--------+-------+---------------+--------------+---------+------+------+-----------------------------------------------------------+
		避免：查询哪些列就根据那些列group by
	解析过程：
		from .. join .. on .. where .. group by .. having .. select (distinct) .. order by .. limit .. 
		已经有表了，但不适用，必须再来一张表
		show create table test02;
		CREATE TABLE test03 (a1 char(3),a2 char(3),a3 char(3),a4 char(3),KEY idx_a1_a2_a3_a4 (a1,a2,a3,a4));
		explain select * from test03 where a2='2' and a4='4' group by a2,a4;
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+--------------------------+
		| id | select_type | table  | type  | possible_keys | key             | key_len | ref  | rows | Extra                    |
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+--------------------------+
		|  1 | SIMPLE      | test03 | index | NULL          | idx_a1_a2_a3_a4 | 40      | NULL |    1 | Using where; Using index |
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+--------------------------+
		explain select * from test03 where a2='2' and a4='4' group by a2,a3;
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+-----------------------------------------------------------+
		| id | select_type | table  | type  | possible_keys | key             | key_len | ref  | rows | Extra                                                     |
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+-----------------------------------------------------------+
		|  1 | SIMPLE      | test03 | index | NULL          | idx_a1_a2_a3_a4 | 40      | NULL |    1 | Using where; Using index; Using temporary; Using filesort |
		+----+-------------+--------+-------+---------------+-----------------+---------+------+------+-----------------------------------------------------------+
		先where后group(在group需要的数据在where已有的表里面查不到结果，索引using temporary)
(iii).using index:性能提升了
	索引覆盖(覆盖索引)，原因：不读取源文件，只从索引文件获取数据，不需要回表查询
	只要使用到的列，全部都在索引中，就是索引覆盖
	show index from test02;
	例如：test02表中有一个复合索引(a1,a2,a3)
		explain select a1,a2 from test02 where a1='' or a2='';
		+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+
		| id | select_type | table  | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |
		+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+
		|  1 | SIMPLE      | test02 | index | idx_a1_a2_a3  | idx_a1_a2_a3 | 30      | NULL |    1 | Using where; Using index |
		+----+-------------+--------+-------+---------------+--------------+---------+------+------+--------------------------+
	drop index idx_a1_a2_a3 on test02;
	alter table test02 add index idx_a1_a2(a1,a2);
	explain select a1,a2 from test02 where a1='' or a3='';
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
	| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra       |
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
	|  1 | SIMPLE      | test02 | ALL  | idx_a1_a2     | NULL | NULL    | NULL |    1 | Using where |
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
	a1,a2无法覆盖a1,a2，所以不是using index
	explain select a1,a2 from test02 where a1='' or a2='';
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+
	| id | select_type | table  | type  | possible_keys | key       | key_len | ref  | rows | Extra                    |
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+
	|  1 | SIMPLE      | test02 | index | idx_a1_a2     | idx_a1_a2 | 20      | NULL |    1 | Using where; Using index |
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+--------------------------+
	explain select a1,a2 from test02;
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+
	| id | select_type | table  | type  | possible_keys | key       | key_len | ref  | rows | Extra       |
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+
	|  1 | SIMPLE      | test02 | index | NULL          | idx_a1_a2 | 20      | NULL |    1 | Using index |
	+----+-------------+--------+-------+---------------+-----------+---------+------+------+-------------+
	索引覆盖会对possible_keys和key造成影响
	如果用到了索引覆盖(using index)，会对possible_keys和key造成影响：
		a.如果没有where，则索引只出现在key中：
		b.如果有where则索引出现在possible_keys和key中
(iv).using where
	需要回表查询，回到原来的表查询
	假设age是索引列，但查询语句select age,name from ... where age=...此语句中必须要回原表查name，因此会显示using where
	explain select a1,a3 from test02 where a3='';
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
	| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra       |
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
	|  1 | SIMPLE      | test02 | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |
	+----+-------------+--------+------+---------------+------+---------+------+------+-------------+
(v).impossible where：where字句用于为false
	explain select a1 from test02 where a1='x' and a1='y';
	+----+-------------+-------+------+---------------+------+---------+------+------+------------------+
	| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra            |
	+----+-------------+-------+------+---------------+------+---------+------+------+------------------+
	|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Impossible WHERE |
	+----+-------------+-------+------+---------------+------+---------+------+------+------------------+

	
	
		
		
		